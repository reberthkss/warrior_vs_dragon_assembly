\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}

\geometry{left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}

\title{Guerreiro vs Dragão: Projeto de Jogo em Assembly MIPS}
\author{Bruno Alves - 147938 \\ Reberth Kelvin Santos de Siqueira - 141589 }
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Este relatório detalha a implementação de "Guerreiro vs Dragão", um jogo de estratégia em turnos desenvolvido como trabalho final para a disciplina de Arquitetura e Organização de Computadores, ministrada pelo Prof. Dr. Fabio Augusto Menocci Cappa no segundo semestre de 2025 na Universidade Federal de São Paulo (UNIFESP). O projeto demonstra conceitos avançados de programação em assembly MIPS, incluindo arquitetura modular, renderização gráfica e lógica de jogo complexa. Uma característica única deste jogo é a mecânica de "Dívida de Juros Compostos", que serve como uma condição de vitória alternativa ao combate tradicional baseado em HP.
\end{abstract}

\tableofcontents
\newpage

\section{Introdução}
"Guerreiro vs Dragão" é um jogo de batalha gráfico em turnos onde o jogador controla um guerreiro lutando contra um dragão. O projeto foi projetado para demonstrar as capacidades da linguagem Assembly MIPS em lidar com lógica, aritmética e E/S mapeada em memória para gráficos.

O objetivo principal é derrotar o dragão reduzindo seus Pontos de Vida (HP) a zero, ou alternativamente, acumular um "Contador de Dívida" de 10.000 através de uma mecânica de juros compostos, efetivamente dominando o inimigo com estratégia econômica.

\section{Arquitetura do Sistema}
O projeto segue uma arquitetura modular para garantir a manutenibilidade e organização do código. A base de código é dividida em vários módulos funcionais:

\begin{itemize}
    \item \textbf{main.asm}: O ponto de entrada da aplicação. Gerencia o loop principal do jogo, verifica as condições de fim de jogo (Vitória/Derrota) e gerencia a lógica de turnos de alto nível.
    \item \textbf{data.asm}: Serve como o repositório central para todas as variáveis de estado do jogo (HP, dívida, contadores de turno), constantes (cores, endereços de memória) e strings de texto (mensagens de UI, perguntas do quiz).
    \item \textbf{battle.asm}: Contém a lógica central de combate. Implementa as funções para os ataques do jogador, comportamento da IA do dragão, cálculos de dano e os algoritmos de juros compostos.
    \item \textbf{quiz.asm}: Implementa um sub-sistema educacional. Gerencia a habilidade "Quiz", lidando com a seleção de perguntas, validação de respostas e aplicação de recompensas especiais por respostas corretas.
    \item \textbf{rendering.asm}: O motor gráfico. Lida com escritas diretas no display mapeado em memória (0x10040000) para renderizar o céu, chão, sprites (Guerreiro e Dragão) e barras de HP dinâmicas.
\end{itemize}

\section{Mecânicas de Jogo}

\subsection{Sistema de Combate}
O combate é baseado em turnos. O jogador tem acesso a seis ações distintas:
\begin{enumerate}
    \item \textbf{Ataque Normal}: Dano padrão com uma taxa de acerto equilibrada (80\%), dano: 10-19 HP (25 crítico).
    \item \textbf{Espada (Sword)}: Um movimento tático que atordoa o dragão, fazendo-o perder um turno, mas não causa dano direto. Taxa de acerto: 80\%.
    \item \textbf{Flanco (Flank)}: Um ataque de alto risco e alta recompensa com 40\% de chance de acerto crítico. Dano: 15-24 HP (30 crítico).
    \item \textbf{Lança (Lance)}: Uma postura defensiva que causa menos dano (5-9 HP, 15 crítico), mas aumenta a evasão do jogador para o próximo turno.
    \item \textbf{Quiz}: Uma habilidade especial que aciona uma pergunta sobre arquitetura de computadores.
    \item \textbf{Estus Flask}: Um item consumível em referência ao jogo Dark Souls. Regenera 25 HP por turno durante 2 turnos. O jogador começa com 2 frascos.
\end{enumerate}

O Dragão atua como o oponente de IA com quatro comportamentos aleatórios (25\% cada):
\begin{itemize}
    \item \textbf{Sopro de Fogo}: Ataque padrão com dano de 25-40 HP (60 crítico). Taxa de acerto: 65\% com 15\% de chance de crítico.
    \item \textbf{Pisar (Stomp)}: Atordoa o jogador, reduzindo a dívida em 5\%. Sem dano direto.
    \item \textbf{Voar (Fly)}: Aumenta a evasão do dragão, tornando-o mais difícil de acertar. Requer 50+ para acertar no próximo turno.
    \item \textbf{Inferno}: Um ataque devastador que causa 45-65 HP de dano com 80\% de taxa de acerto, ignorando a maioria dos bônus de evasão do jogador.
\end{itemize}

\subsection{Sistema de Dívida de Juros Compostos}
Uma mecânica única envolvendo um "Contador de Dívida".
\begin{itemize}
    \item \textbf{Crescimento}: Cada vez que o jogador acerta um golpe, o contador de dívida cresce 10\% mais um valor base de 100.
    \item \textbf{Redução}: Quando o dragão atinge o jogador, a dívida é reduzida em 5\%, simulando um revés.
    \item \textbf{Vitória}: Se o contador de dívida atingir 10.000, o jogador vence imediatamente via "Vitória por Juros Compostos".
    \item \textbf{Inspiração}: Esta mecânica foi inspirada nas habilidades do personagem Knuckle Bine, do anime \textit{Hunter x Hunter}, onde o acumulo de "juros" de aura leva à derrota do oponente.
\end{itemize}

\subsection{Quiz Educacional}
O jogo integra conteúdo educacional diretamente na jogabilidade. A ação "Quiz" apresenta perguntas aleatórias sobre Arquitetura de Computadores (ex: sobre ULA, RAM, Barramentos).
\begin{itemize}
    \item \textbf{Resposta Correta}: Aplica a fórmula de juros compostos 5 vezes instantaneamente, fornecendo um grande impulso para a condição de vitória por dívida.
    \item \textbf{Resposta Errada}: Penaliza o jogador com perda de HP.
\end{itemize}

\section{Balanceamento e Dinâmica de Dificuldade}
Durante o desenvolvimento iterativo, foi implementado um sistema de balanceamento estratégico para criar dinâmica de complexidade no jogo:

\subsection{Ajustes de Dificuldade}
\begin{itemize}
    \item \textbf{Dano do Dragão}: Aumentado de 20-35 para 25-40 HP, tornando o inimigo mais ameaçador.
    \item \textbf{Chance de Crítico}: Aumentada de 5\% para 15\%, criando momentos de risco maior.
    \item \textbf{Ataque Inferno}: Novo ataque devastador (45-65 HP) com 80\% de acerto, força a tomada de decisões tática.
    \item \textbf{Estus Flasks Limitadas}: Reduzidas de 3 para 2, criando dilema estratégico entre usar agora ou guardar.
    \item \textbf{Duração da Poção}: Reduzida de 3 para 2 rodadas, criando janela de vulnerabilidade.
\end{itemize}

Esta configuração cria decisões tática reais: o jogador deve escolher entre atacar agressivamente, defender-se com Lance, ou gastar seus recursos limitados de Estus Flask preventivamente.

\section{Implementação Técnica}

\subsection{Arquitetura Modular Melhorada}
Para facilitar a manutenção e reutilização de código, a arquitetura foi reorganizada em arquivos especializados:

\begin{itemize}
    \item \textbf{macros.asm}: Define macros globais como \texttt{draw\_rectangle} que são reutilizadas em todo o projeto.
    \item \textbf{include\_all.asm}: Arquivo centralizador que garante a ordem correta de inclusão de módulos, evitando problemas de símbolos não encontrados.
\end{itemize}

A ordem de carregamento é crítica: macros → dados → sprites → lógica de batalha → quiz → renderização.

\subsection{Motor Gráfico}
O jogo roda em um display de 256x256 pixels com profundidade de cor de 32 bits. O módulo \texttt{rendering.asm} usa endereçamento de memória eficiente para desenhar os pixels.
\begin{itemize}
    \item \textbf{Cálculo de Endereço}: $Base + (Y \times 256 + X) \times 4$. A multiplicação por 256 é otimizada usando um deslocamento lógico à esquerda (\texttt{sll}) de 8 bits.
    \item \textbf{Sprites}: Sprites são armazenados com cabeçalhos de largura e altura, e o loop de renderização ignora a cor de transparência (0x00000000) para sobrepor os personagens no fundo.
\end{itemize}

\subsection{Geração de Números Aleatórios}
O jogo utiliza extensivamente a chamada de sistema (syscall) 42 para gerar números aleatórios para determinar:
\begin{itemize}
    \item Sucesso do ataque (cálculos de Acerto/Erro).
    \item Acertos críticos.
    \item Escolhas da IA do Dragão.
    \item Seleção de perguntas do Quiz.
\end{itemize}

\subsection{Ambiente de Teste}
O projeto foi desenvolvido e validado utilizando o simulador MARS (MIPS Assembler and Runtime Simulator). Para a saída gráfica, foi utilizada a ferramenta \textit{Bitmap Display} incluída no simulador, com as seguintes configurações específicas para garantir a visualização correta:

\begin{itemize}
    \item \textbf{Unit Width in Pixels}: 1
    \item \textbf{Unit Height in Pixels}: 1
    \item \textbf{Display Width in Pixels}: 256
    \item \textbf{Display Height in Pixels}: 256
    \item \textbf{Base address for display}: 0x10040000 (heap)
\end{itemize}

\section{Desafios e Decisões de Projeto}
Durante o desenvolvimento do projeto, foram identificados desafios técnicos significativos, especialmente relacionados à renderização gráfica. Um dos principais obstáculos foi o desenho do \textit{bitmap}, onde inicialmente tentou-se utilizar um endereço de memória estático para a manipulação dos pixels. No entanto, para o correto funcionamento com a ferramenta de display gráfico do simulador, deveríamos ter utilizado o endereço de memória da \textit{heap} (dinâmica). Essa divergência causou dificuldades iniciais na exibição correta das sprites e cores na tela, exigindo uma refatoração do código de renderização para apontar para o endereço base correto (0x10040000).

Além disso, devido à complexidade inerente ao desenvolvimento em baixo nível com Assembly, foi tomada a decisão de priorizar a profundidade e robustez das mecânicas de jogo — como o sistema de combate, as perguntas do quiz e o cálculo de juros compostos — em detrimento de uma apresentação visual mais elaborada. O foco principal foi garantir que a lógica do jogo funcionasse perfeitamente, mantendo os gráficos funcionais, porém simples, para assegurar a entrega de um sistema estável e livre de bugs críticos.

\section{Conclusão}
O projeto "Guerreiro vs Dragão" cria com sucesso uma aplicação interativa e envolvente usando linguagem Assembly de baixo nível. Ele demonstra que lógica complexa, design de software modular e interfaces gráficas podem ser efetivamente implementados mesmo sem abstrações de alto nível, fornecendo insights profundos sobre arquitetura de computadores e operações em nível de máquina.

\end{document}
